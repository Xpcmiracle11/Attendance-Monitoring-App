import { Socket } from 'net';
import { RealTimeLog } from './helper/utils';
import { Finger } from './models/Finger';
import { User } from './models/User';
export declare class ZTCP {
    /**
    * @param_ip ip address of device
    * @param_port port number of device
    * @param_timeout connection timout
    * @param_comm_key communication key of device (if the case)
    * @return Zkteco TCP socket connection instance
    */
    private ip;
    private port;
    private timeout;
    private sessionId;
    private replyId;
    socket: Socket | undefined;
    private comm_key;
    private user_count;
    private fp_count;
    private pwd_count;
    private oplog_count;
    private attlog_count;
    private fp_cap;
    private user_cap;
    private attlog_cap;
    private fp_av;
    private user_av;
    private attlog_av;
    private face_count;
    private face_cap;
    private userPacketSize;
    private verbose;
    constructor(ip: string, port: number, timeout: number, comm_key: number, verbose: boolean);
    createSocket(cbError: any, cbClose: any): Promise<unknown>;
    connect(): Promise<boolean>;
    closeSocket(): Promise<boolean>;
    writeMessage(msg: Buffer, connect: boolean): Promise<Buffer>;
    requestData(msg: Buffer): Promise<Buffer>;
    /**
     *
     * @param {*} command
     * @param {*} data
     *
     *
     * reject error when command fail and resolve data when success
     */
    executeCmd(command: number, data: Buffer | string | ArrayBuffer): Promise<Buffer>;
    sendChunkRequest(start: number, size: number): Promise<any>;
    /**
     *
     * @param {*} reqData - indicate the type of data that need to receive ( user or attLog)
     * @param {*} cb - callback is triggered when receiving packets
     *
     * readWithBuffer will reject error if it'wrong when starting request data
     * readWithBuffer will return { data: replyData , err: Error } when receiving requested data
     */
    readWithBuffer(reqData: Buffer | string, cb?: any): Promise<Record<string, Buffer | number>>;
    /**
     *  reject error when starting request data
     *  @return {Record<string, User[] | Error>} when receiving requested data
     */
    getUsers(): Promise<{
        data: User[];
    }>;
    /**
     *
     * @param {*} ip
     * @param {*} callbackInProcess
     *  reject error when starting request data
     *  return { data: records, err: Error } when receiving requested data
     */
    getAttendances(callbackInProcess?: any): Promise<{
        data: any[];
    }>;
    freeData(): Promise<boolean>;
    disableDevice(): Promise<boolean>;
    enableDevice(): Promise<boolean>;
    disconnect(): Promise<void>;
    getInfo(): Promise<{
        userCounts: number;
        logCounts: number;
        logCapacity: number;
    }>;
    getSizes(): Promise<{
        userCounts: number;
        logCounts: number;
        fingerCount: number;
        adminCount: number;
        opLogCount: number;
        logCapacity: number;
        fingerCapacity: number;
        userCapacity: number;
        attLogCapacity: number;
        fingerAvailable: number;
        userAvailable: number;
        attLogAvailable: number;
        faceCount: number;
        faceCapacity: number;
    }>;
    getVendor(): Promise<string>;
    getProductTime(): Promise<Date>;
    getMacAddress(): Promise<string>;
    getSerialNumber(): Promise<string>;
    getDeviceVersion(): Promise<string>;
    getDeviceName(): Promise<string>;
    getPlatform(): Promise<string>;
    getOS(): Promise<string>;
    getWorkCode(): Promise<string>;
    getPIN(): Promise<string>;
    getFaceOn(): Promise<"No" | "Yes">;
    getSSR(): Promise<string>;
    getFirmware(): Promise<string>;
    getTime(): Promise<Date>;
    setTime(tm: Date | string): Promise<boolean>;
    voiceTest(): Promise<void>;
    setUser(uid: number, userid: string, name: string, password: string, role?: number, cardno?: number): Promise<boolean>;
    deleteUser(uid: number): Promise<boolean>;
    getAttendanceSize(): Promise<number>;
    clearAttendanceLog(): Promise<Buffer<ArrayBufferLike>>;
    clearData(): Promise<Buffer<ArrayBufferLike>>;
    getRealTimeLogs(cb?: (realTimeLog: RealTimeLog) => void): Promise<void>;
    getTemplates(): Promise<Finger[]>;
    refreshData(): Promise<boolean>;
    sendWithBuffer(buffer: Buffer): Promise<unknown>;
    sendChunk(commandString: Buffer): Promise<unknown>;
    /**
     * save user and template
     *
     * @param {User | number | string} user - User class object | uid | user_id
     * @param {Finger[]} fingers - Array of finger class. `0 <= index <= 9`
     */
    saveUserTemplate(user: User, fingers?: Finger[]): Promise<void>;
    deleteFinger(uid: number, fid: number): Promise<boolean>;
    enrollUser(uid: number, tempId: number, userId?: string): Promise<boolean>;
    readSocket(length: number, cb?: any): Promise<any>;
    /**
     * Register events
     * @param {number} flags - Event flags
     * @returns {Promise<void>}
     * @throws {ZKErrorResponse} If registration fails
     */
    regEvent(flags: any): Promise<void>;
    ackOk(): Promise<void>;
    cancelCapture(): Promise<boolean>;
    verifyUser(uid: number): Promise<boolean>;
    restartDevice(): Promise<void>;
}

'use strict';

var net = require('net');
var fs = require('fs');
var dgram = require('node:dgram');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var dgram__namespace = /*#__PURE__*/_interopNamespaceDefault(dgram);

const COMMANDS = {
    CMD_CONNECT: 1000,
    CMD_EXIT: 1001,
    CMD_ENABLEDEVICE: 1002,
    CMD_DISABLEDEVICE: 1003,
    CMD_RESTART: 1004,
    CMD_POWEROFF: 1005,
    CMD_SLEEP: 1006,
    CMD_RESUME: 1007,
    CMD_CAPTUREFINGER: 1009,
    CMD_TEST_TEMP: 1011,
    CMD_CAPTUREIMAGE: 1012,
    CMD_REFRESHDATA: 1013,
    CMD_REFRESHOPTION: 1014,
    CMD_TESTVOICE: 1017,
    CMD_GET_VERSION: 1100,
    CMD_CHANGE_SPEED: 1101,
    CMD_AUTH: 1102,
    CMD_PREPARE_DATA: 1500,
    CMD_DATA: 1501,
    CMD_FREE_DATA: 1502,
    CMD_DATA_WRRQ: 1503,
    CMD_DATA_RDY: 1504,
    CMD_DB_RRQ: 7,
    CMD_USER_WRQ: 8,
    CMD_USERTEMP_RRQ: 9,
    CMD_USERTEMP_WRQ: 10,
    CMD_OPTIONS_RRQ: 11,
    CMD_OPTIONS_WRQ: 12,
    CMD_ATTLOG_RRQ: 13,
    CMD_CLEAR_DATA: 14,
    CMD_CLEAR_ATTLOG: 15,
    CMD_DELETE_USER: 18,
    CMD_DELETE_USERTEMP: 19,
    CMD_CLEAR_ADMIN: 20,
    CMD_USERGRP_RRQ: 21,
    CMD_USERGRP_WRQ: 22,
    CMD_USERTZ_RRQ: 23,
    CMD_USERTZ_WRQ: 24,
    CMD_GRPTZ_RRQ: 25,
    CMD_GRPTZ_WRQ: 26,
    CMD_TZ_RRQ: 27,
    CMD_TZ_WRQ: 28,
    CMD_ULG_RRQ: 29,
    CMD_ULG_WRQ: 30,
    CMD_UNLOCK: 31,
    CMD_CLEAR_ACC: 32,
    CMD_CLEAR_OPLOG: 33,
    CMD_OPLOG_RRQ: 34,
    CMD_GET_FREE_SIZES: 50,
    CMD_ENABLE_CLOCK: 57,
    CMD_STARTVERIFY: 60,
    CMD_STARTENROLL: 61,
    CMD_CANCELCAPTURE: 62,
    CMD_STATE_RRQ: 64,
    CMD_WRITE_LCD: 66,
    CMD_CLEAR_LCD: 67,
    CMD_GET_PINWIDTH: 69,
    CMD_SMS_WRQ: 70,
    CMD_SMS_RRQ: 71,
    CMD_DELETE_SMS: 72,
    CMD_UDATA_WRQ: 73,
    CMD_DELETE_UDATA: 74,
    CMD_DOORSTATE_RRQ: 75,
    CMD_WRITE_MIFARE: 76,
    CMD_EMPTY_MIFARE: 78,
    CMD_VERIFY_WRQ: 79,
    CMD_VERIFY_RRQ: 80,
    CMD_TMP_WRITE: 87,
    CMD_GET_USERTEMP: 88,
    CMD_CHECKSUM_BUFFER: 119,
    CMD_DEL_FPTMP: 134,
    CMD_GET_TIME: 201,
    CMD_SET_TIME: 202,
    CMD_REG_EVENT: 500,
    CMD_ACK_OK: 2000,
    CMD_ACK_ERROR: 2001,
    CMD_ACK_DATA: 2002,
    CMD_ACK_RETRY: 2003,
    CMD_ACK_REPEAT: 2004,
    CMD_ACK_UNAUTH: 2005,
    CMD_ACK_UNKNOWN: 65535,
    CMD_ACK_ERROR_CMD: 65533,
    CMD_ACK_ERROR_INIT: 65532,
    CMD_ACK_ERROR_DATA: 65531,
    EF_ATTLOG: 1,
    EF_FINGER: 2,
    EF_ENROLLUSER: 4,
    EF_ENROLLFINGER: 8,
    EF_BUTTON: 16,
    EF_UNLOCK: 32,
    EF_VERIFY: 128,
    EF_FPFTR: 256,
    EF_ALARM: 512
};
const USHRT_MAX = 65535;
const MAX_CHUNK = 65472;
const REQUEST_DATA = {
    DISABLE_DEVICE: Buffer.from([0, 0, 0, 0]),
    GET_REAL_TIME_EVENT: Buffer.from([0x01, 0x00, 0x00, 0x00]),
    GET_ATTENDANCE_LOGS: Buffer.from([0x01, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    GET_USERS: Buffer.from([0x01, 0x09, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
    GET_TEMPLATES: Buffer.from([0x01, 0x07, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])
};

/**
 *
 * @param {number} time
 */
const decode = time => {
    const second = time % 60;
    time = (time - second) / 60;
    const minute = time % 60;
    time = (time - minute) / 60;
    const hour = time % 24;
    time = (time - hour) / 24;
    const day = time % 31 + 1;
    time = (time - (day - 1)) / 31;
    const month = time % 12;
    time = (time - month) / 12;
    const year = time + 2000;
    return new Date(year, month, day, hour, minute, second);
};
/**
 *
 * @param {Date} date
 */
const encode = date => {
    return (((date.getFullYear() % 100) * 12 * 31 + date.getMonth() * 31 + date.getDate() - 1) * (24 * 60 * 60) +
        (date.getHours() * 60 + date.getMinutes()) * 60 +
        date.getSeconds());
};
var timeParser = { encode, decode };

const parseCurrentTime = () => {
    const currentTime = new Date();
    return {
        year: currentTime.getFullYear(),
        month: currentTime.getMonth() + 1,
        day: currentTime.getDate(),
        hour: currentTime.getHours(),
        second: currentTime.getSeconds()
    };
};
const log = (text) => {
    const currentTime = parseCurrentTime();
    const fileName = `${currentTime.day}`.padStart(2, '0') +
        `${currentTime.month}`.padStart(2, '0') +
        `${currentTime.year}.err.log`;
    const logMessage = `\n [${currentTime.hour}:${currentTime.second}] ${text}`;
    fs.appendFile(fileName, logMessage, () => { });
};

/**
 * Represents a User as is from ZkDevice and contain methods
 * */
class User {
    uid;
    name;
    privilege;
    password;
    group_id;
    user_id;
    card;
    /**
     * Creates a new User instance
     * @param uid User ID
     * @param name User name
     * @param privilege Privilege level
     * @param password User password (default: "")
     * @param group_id Group ID (default: "")
     * @param user_id Alternate user ID (default: "")
     * @param card Card number (default: 0)
     */
    constructor(uid, name, privilege, password = "", group_id = "", user_id = "", card = 0) {
        this.uid = uid;
        this.name = name;
        this.privilege = privilege;
        this.password = password;
        this.group_id = group_id;
        this.user_id = user_id;
        this.card = card;
    }
    ensureEncoding(string) {
        try {
            return decodeURIComponent(string);
        }
        catch (e) {
            return unescape(string);
        }
    }
    repack29() {
        // Pack format: <BHB5s8sIxBhI (total 29 bytes)
        const buf = Buffer.alloc(29);
        let offset = 0;
        buf.writeUInt8(2, offset);
        offset += 1;
        buf.writeUInt16LE(this.uid, offset);
        offset += 2;
        buf.writeUInt8(this.privilege, offset);
        offset += 1;
        const passwordBuf = Buffer.from(this.ensureEncoding(this.password));
        passwordBuf.copy(buf, offset, 0, 5);
        offset += 5;
        const nameBuf = Buffer.from(this.ensureEncoding(this.name));
        nameBuf.copy(buf, offset, 0, 8);
        offset += 8;
        buf.writeUInt32LE(this.card, offset);
        offset += 4;
        offset += 1; // padding byte
        buf.writeUInt8(0, offset);
        offset += 1;
        buf.writeUInt32LE(parseInt(this.user_id) || 0, offset);
        return buf;
    }
    repack73() {
        // Pack format: <BHB8s24sIB7sx24s (total 73 bytes)
        const buf = Buffer.alloc(73);
        let offset = 0;
        buf.writeUInt8(2, offset);
        offset += 1;
        buf.writeUInt16LE(this.uid, offset);
        offset += 2;
        buf.writeUInt8(this.privilege, offset);
        offset += 1;
        const passwordBuf = Buffer.from(this.ensureEncoding(this.password));
        passwordBuf.copy(buf, offset, 0, 8);
        offset += 8;
        const nameBuf = Buffer.from(this.ensureEncoding(this.name));
        nameBuf.copy(buf, offset, 0, 24);
        offset += 24;
        buf.writeUInt32LE(this.card, offset);
        offset += 4;
        buf.writeUInt8(1, offset);
        offset += 1;
        const groupBuf = Buffer.from(this.ensureEncoding(String(this.group_id)));
        groupBuf.copy(buf, offset, 0, 7);
        offset += 8;
        const userIdBuf = Buffer.from(this.ensureEncoding(String(this.user_id)));
        userIdBuf.copy(buf, offset, 0, 24);
        return buf;
    }
}

class Attendance {
    sn;
    user_id;
    record_time;
    type;
    state;
    ip;
    constructor(sn, user_id, record_time, type, state) {
        this.sn = sn;
        this.user_id = user_id;
        this.record_time = record_time;
        this.type = type;
        this.state = state;
    }
}

const parseHexToTime = (hex) => {
    const time = {
        year: hex.readUIntLE(0, 1),
        month: hex.readUIntLE(1, 1),
        date: hex.readUIntLE(2, 1),
        hour: hex.readUIntLE(3, 1),
        minute: hex.readUIntLE(4, 1),
        second: hex.readUIntLE(5, 1)
    };
    return new Date(2000 + time.year, time.month - 1, time.date, time.hour, time.minute, time.second);
};
const createChkSum = (buf) => {
    let chksum = 0;
    for (let i = 0; i < buf.length; i += 2) {
        if (i === buf.length - 1) {
            chksum += buf[i];
        }
        else {
            chksum += buf.readUInt16LE(i);
        }
        chksum %= USHRT_MAX;
    }
    chksum = USHRT_MAX - chksum - 1;
    return chksum;
};
const createUDPHeader = (command, sessionId, replyId, data) => {
    const dataBuffer = Buffer.from(data);
    const buf = Buffer.alloc(8 + dataBuffer.length);
    buf.writeUInt16LE(command, 0);
    buf.writeUInt16LE(0, 2);
    buf.writeUInt16LE(sessionId, 4);
    buf.writeUInt16LE(replyId, 6);
    dataBuffer.copy(buf, 8);
    const chksum2 = createChkSum(buf);
    buf.writeUInt16LE(chksum2, 2);
    replyId = (replyId + 1) % USHRT_MAX;
    buf.writeUInt16LE(replyId, 6);
    return buf;
};
const createTCPHeader = (command, sessionId, replyId, data) => {
    const dataBuffer = Buffer.from(data);
    const buf = Buffer.alloc(8 + dataBuffer.length);
    buf.writeUInt16LE(command, 0);
    buf.writeUInt16LE(0, 2);
    buf.writeUInt16LE(sessionId, 4);
    buf.writeUInt16LE(replyId, 6);
    dataBuffer.copy(buf, 8);
    const chksum2 = createChkSum(buf);
    buf.writeUInt16LE(chksum2, 2);
    replyId = (replyId + 1) % USHRT_MAX;
    buf.writeUInt16LE(replyId, 6);
    const prefixBuf = Buffer.from([0x50, 0x50, 0x82, 0x7d, 0x13, 0x00, 0x00, 0x00]);
    prefixBuf.writeUInt16LE(buf.length, 4);
    return Buffer.concat([prefixBuf, buf]);
};
const removeTcpHeader = (buf) => {
    if (buf.length < 8) {
        return buf;
    }
    if (buf.compare(Buffer.from([0x50, 0x50, 0x82, 0x7d]), 0, 4, 0, 4) !== 0) {
        return buf;
    }
    return buf.slice(8);
};
const parseTimeToDate = (time) => {
    const second = time % 60;
    time = (time - second) / 60;
    const minute = time % 60;
    time = (time - minute) / 60;
    const hour = time % 24;
    time = (time - hour) / 24;
    const day = time % 31 + 1;
    time = (time - (day - 1)) / 31;
    const month = time % 12;
    time = (time - month) / 12;
    const year = time + 2000;
    return new Date(year, month, day, hour, minute, second);
};
const decodeUserData28 = (userData) => {
    return {
        uid: userData.readUIntLE(0, 2),
        privilege: userData.readUIntLE(2, 1),
        name: userData
            .slice(8, 8 + 8)
            .toString('ascii')
            .split('\0')
            .shift() || '',
        user_id: userData.readUIntLE(24, 4).toString(),
    };
};
const decodeUserData72 = (userData) => {
    return new User(userData.readUIntLE(0, 2), userData
        .slice(11)
        .toString('ascii')
        .split('\0')
        .shift() || '', userData.readUIntLE(2, 1), userData
        .subarray(3, 3 + 8)
        .toString('ascii')
        .split('\0')
        .shift() || '', userData.readUIntLE(39, 1), userData
        .slice(48, 48 + 9)
        .toString('ascii')
        .split('\0')
        .shift() || '', userData.readUIntLE(35, 4));
};
const decodeRecordData40 = (recordData) => {
    return new Attendance(recordData.readUIntLE(0, 2), recordData
        .slice(2, 2 + 9)
        .toString('ascii')
        .split('\0')
        .shift() || '', parseTimeToDate(recordData.readUInt32LE(27)), recordData.readUIntLE(26, 1), recordData.readUIntLE(31, 1));
};
const decodeRecordData16 = (recordData) => {
    return {
        user_id: recordData.readUIntLE(0, 2).toString(),
        record_time: parseTimeToDate(recordData.readUInt32LE(4))
    };
};
const decodeRecordRealTimeLog18 = (recordData) => {
    const user_id = recordData.readUIntLE(8, 1).toString();
    const record_time = parseHexToTime(recordData.subarray(12, 18));
    return { user_id, record_time };
};
const decodeRecordRealTimeLog52 = (recordData) => {
    const payload = removeTcpHeader(recordData);
    const recvData = payload.subarray(8);
    const user_id = recvData.slice(0, 9)
        .toString('ascii')
        .split('\0')
        .shift() || '';
    const record_time = parseHexToTime(recvData.subarray(26, 26 + 6));
    return { user_id, record_time };
};
const decodeUDPHeader = (header) => {
    return {
        commandId: header.readUIntLE(0, 2),
        checkSum: header.readUIntLE(2, 2),
        sessionId: header.readUIntLE(4, 2),
        replyId: header.readUIntLE(6, 2)
    };
};
const decodeTCPHeader = (header) => {
    const recvData = header.subarray(8);
    const payloadSize = header.readUIntLE(4, 2);
    return {
        commandId: recvData.readUIntLE(0, 2),
        checkSum: recvData.readUIntLE(2, 2),
        sessionId: recvData.readUIntLE(4, 2),
        replyId: recvData.readUIntLE(6, 2),
        payloadSize
    };
};
const exportErrorMessage = (commandValue) => {
    const keys = Object.keys(COMMANDS);
    for (const key of keys) {
        if (COMMANDS[key] === commandValue) {
            return key.toString();
        }
    }
    return 'AN UNKNOWN ERROR';
};
const checkNotEventTCP = (data) => {
    try {
        const cleanedData = removeTcpHeader(data);
        const commandId = cleanedData.readUIntLE(0, 2);
        const event = cleanedData.readUIntLE(4, 2);
        return event === COMMANDS.EF_ATTLOG && commandId === COMMANDS.CMD_REG_EVENT;
    }
    catch (err) {
        log(`[228] : ${err.toString()} ,${data.toString('hex')} `);
        return false;
    }
};
const checkNotEventUDP = (data) => {
    const { commandId } = decodeUDPHeader(data.subarray(0, 8));
    return commandId === COMMANDS.CMD_REG_EVENT;
};
const makeKey = (key, sessionId) => {
    let k = 0;
    for (let i = 0; i < 32; i++) {
        if ((key & (1 << i)) !== 0) {
            k = (k << 1) | 1;
        }
        else {
            k = k << 1;
        }
    }
    k += sessionId;
    let hex = k.toString(16).padStart(8, "0");
    let response = new Uint8Array(4);
    let index = 3;
    while (hex.length > 0) {
        response[index] = parseInt(hex.substring(0, 2), 16);
        index--;
        hex = hex.substring(2);
    }
    response[0] ^= 'Z'.charCodeAt(0);
    response[1] ^= 'K'.charCodeAt(0);
    response[2] ^= 'S'.charCodeAt(0);
    response[3] ^= 'O'.charCodeAt(0);
    let finalKey = response[0] +
        (response[1] << 8) +
        (response[2] << 16) +
        (response[3] << 24);
    let swp = finalKey >>> 16;
    finalKey = (finalKey << 16) | swp;
    return finalKey >>> 0;
};
const authKey = (comKey, sessionId) => {
    let k = makeKey(comKey, sessionId) >>> 0;
    let rand = Math.floor(Math.random() * 256);
    let hex = k.toString(16).padStart(8, "0");
    let response = new Uint8Array(4);
    let index = 3;
    while (index >= 0) {
        response[index] = parseInt(hex.substring(0, 2), 16);
        index--;
        hex = hex.substring(2);
    }
    response[0] ^= rand;
    response[1] ^= rand;
    response[2] = rand;
    response[3] ^= rand;
    return Array.from(response);
};

/**
 * Represents a fingerprint template with associated metadata
 */
class Finger {
    uid;
    fid;
    valid;
    template;
    size;
    mark;
    /**
     * Creates a new Finger instance
     * @param uid User internal reference
     * @param fid Finger ID (value >= 0 && value <= 9)
     * @param valid Flag indicating 0 = invalid | 1 = valid | 3 = duress
     * @param template Fingerprint template data buffer
     */
    constructor(uid, fid, valid, template) {
        this.uid = Number(uid);
        this.fid = Number(fid);
        this.valid = Number(valid);
        this.template = template;
        this.size = template.length;
        // Create mark showing first and last 8 bytes as hex
        const start = template.slice(0, 8).toString('hex');
        const end = template.slice(-8).toString('hex');
        this.mark = `${start}...${end}`;
    }
    /**
     * Packs the fingerprint data with metadata into a Buffer
     * @returns Buffer containing packed fingerprint data
     */
    repack() {
        // pack("HHbb%is" % (self.size), self.size+6, self.uid, self.fid, self.valid, self.template)
        const buf = Buffer.alloc(6 + this.size); // HHbb = 6 bytes + template size
        let offset = 0;
        buf.writeUInt16LE(this.size + 6, offset);
        offset += 2;
        buf.writeUInt16LE(this.uid, offset);
        offset += 2;
        buf.writeUInt8(this.fid, offset);
        offset += 1;
        buf.writeUInt8(this.valid, offset);
        offset += 1;
        this.template.copy(buf, offset);
        return buf;
    }
    /**
     * Packs only the fingerprint template data into a Buffer
     * @returns Buffer containing just the template data
     */
    repackOnly() {
        // pack("H%is" % (self.size), self.size, self.template)
        const buf = Buffer.alloc(2 + this.size); // H = 2 bytes + template size
        buf.writeUInt16LE(this.size, 0);
        this.template.copy(buf, 2);
        return buf;
    }
    /**
     * Compares this fingerprint with another for equality
     * @param other Another Finger instance to compare with
     * @returns true if all properties and template data match
     */
    equals(other) {
        if (!(other instanceof Finger))
            return false;
        return this.uid === other.uid &&
            this.fid === other.fid &&
            this.valid === other.valid &&
            this.template.equals(other.template);
    }
}

/**
 * Error types for device communication
 */
const ERROR_TYPES = {
    ECONNRESET: 'ECONNRESET',
    ECONNREFUSED: 'ECONNREFUSED'};
/**
 * Custom error class for device communication errors
 */
class ZkError {
    err;
    ip;
    command;
    /**
     * Creates a new ZkError instance
     * @param err The error object
     * @param command The command that caused the error
     * @param ip The IP address of the device
     */
    constructor(err, command, ip) {
        this.err = err;
        this.ip = ip;
        this.command = command;
    }
    /**
     * Gets a user-friendly error message
     * @returns A formatted error message
     */
    toast() {
        if (this.err.code === ERROR_TYPES.ECONNRESET) {
            return 'Another device is connecting to the device so the connection is interrupted';
        }
        else if (this.err.code === ERROR_TYPES.ECONNREFUSED) {
            return 'IP of the device is refused';
        }
        return this.err.message;
    }
    /**
     * Gets detailed error information
     * @returns An object containing error details
     */
    getError() {
        return {
            err: {
                message: this.err.message,
                code: this.err.code
            },
            ip: this.ip,
            command: this.command
        };
    }
}

class ZTCP {
    /**
    * @param_ip ip address of device
    * @param_port port number of device
    * @param_timeout connection timout
    * @param_comm_key communication key of device (if the case)
    * @return Zkteco TCP socket connection instance
    */
    ip;
    port;
    timeout;
    sessionId = 0;
    replyId = 0;
    socket;
    comm_key;
    user_count = 0;
    fp_count = 0;
    pwd_count = 0;
    oplog_count = 0;
    attlog_count = 0;
    fp_cap = 0;
    user_cap = 0;
    attlog_cap = 0;
    fp_av = 0;
    user_av = 0;
    attlog_av = 0;
    face_count = 0;
    face_cap = 0;
    userPacketSize = 72;
    verbose = false;
    constructor(ip, port, timeout, comm_key, verbose) {
        this.ip = ip;
        this.port = port;
        this.timeout = timeout;
        this.replyId = 0;
        this.comm_key = comm_key;
        this.verbose = verbose;
    }
    createSocket(cbError, cbClose) {
        return new Promise((resolve, reject) => {
            this.socket = new net.Socket();
            // Handle socket error
            this.socket.once('error', (err) => {
                this.socket = undefined; // Ensure socket reference is cleared
                reject(err);
                if (typeof cbError === 'function')
                    cbError(err);
            });
            // Handle successful connection
            this.socket.once('connect', () => {
                resolve(this.socket);
            });
            // Handle socket closure
            this.socket.once('close', () => {
                this.socket = undefined; // Ensure socket reference is cleared
                if (typeof cbClose === 'function')
                    cbClose('tcp');
            });
            // Set socket timeout if provided
            if (this.timeout) {
                this.socket.setTimeout(this.timeout);
            }
            // Initiate connection
            this.socket.connect(this.port, this.ip);
        });
    }
    async connect() {
        try {
            let reply = await this.executeCmd(COMMANDS.CMD_CONNECT, '');
            if (reply.readUInt16LE(0) === COMMANDS.CMD_ACK_OK) {
                return true;
            }
            if (reply.readUInt16LE(0) === COMMANDS.CMD_ACK_UNAUTH) {
                const hashedCommkey = authKey(this.comm_key, this.sessionId);
                reply = await this.executeCmd(COMMANDS.CMD_AUTH, hashedCommkey);
                if (reply.readUInt16LE(0) === COMMANDS.CMD_ACK_OK) {
                    return true;
                }
                else {
                    throw new Error("error de authenticacion");
                }
            }
            else {
                // No reply received; throw an error
                throw new Error('NO_REPLY_ON_CMD_CONNECT');
            }
        }
        catch (err) {
            // Log the error for debugging, if necessary
            console.error('Failed to connect:', err);
            // Re-throw the error for handling by the caller
            throw err;
        }
    }
    async closeSocket() {
        return new Promise((resolve, reject) => {
            // If no socket is present, resolve immediately
            if (!this.socket) {
                return resolve(true);
            }
            // Clean up listeners to avoid potential memory leaks or duplicate handling
            this.socket.removeAllListeners('data');
            // Set a timeout to handle cases where socket.end might not resolve
            const timer = setTimeout(() => {
                this.socket.destroy(); // Forcibly close the socket if not closed properly
                resolve(true); // Resolve even if the socket was not closed properly
            }, 2000);
            // Close the socket and clear the timeout upon successful completion
            this.socket.end(() => {
                clearTimeout(timer);
                resolve(true); // Resolve once the socket has ended
            });
            // Handle socket errors during closing
            this.socket.once('error', (err) => {
                clearTimeout(timer);
                reject(err); // Reject the promise with the error
            });
        });
    }
    writeMessage(msg, connect) {
        return new Promise((resolve, reject) => {
            // Check if the socket is initialized
            if (!this.socket) {
                return reject(new Error('Socket is not initialized'));
            }
            // Define a variable for the timeout reference
            let timer = null;
            // Handle incoming data
            const onData = (data) => {
                // Check if the socket is still valid before trying to remove the listener
                if (this.socket) {
                    this.socket.removeListener('data', onData); // Remove the data event listener
                }
                clearTimeout(timer); // Clear the timeout once data is received
                resolve(data); // Resolve the promise with the received data
            };
            // Attach the data event listener
            this.socket.once('data', onData);
            // Attempt to write the message to the socket
            this.socket.write(msg, null, (err) => {
                if (err) {
                    // Check if the socket is still valid before trying to remove the listener
                    if (this.socket) {
                        this.socket.removeListener('data', onData); // Clean up listener on write error
                    }
                    return reject(err); // Reject the promise with the write error
                }
                // If a timeout is set, configure it
                if (this.timeout) {
                    timer = setTimeout(() => {
                        // Check if the socket is still valid before trying to remove the listener
                        if (this.socket) {
                            this.socket.removeListener('data', onData); // Remove listener on timeout
                        }
                        reject(new Error('TIMEOUT_ON_WRITING_MESSAGE')); // Reject the promise on timeout
                    }, connect ? 2000 : this.timeout);
                }
            });
        });
    }
    async requestData(msg) {
        try {
            return await new Promise((resolve, reject) => {
                let timer = null;
                let replyBuffer = Buffer.from([]);
                // Internal callback to handle data reception
                const internalCallback = (data_1) => {
                    if (this.socket) {
                        this.socket.removeListener('data', handleOnData); // Clean up listener
                    }
                    if (timer)
                        clearTimeout(timer); // Clear the timeout
                    resolve(data_1); // Resolve the promise with the data
                };
                // Handle incoming data
                const handleOnData = (data_3) => {
                    replyBuffer = Buffer.concat([replyBuffer, data_3]); // Accumulate data
                    // Check if the data is a valid TCP event
                    if (checkNotEventTCP(data_3))
                        return;
                    // Decode the TCP header
                    const header = decodeTCPHeader(replyBuffer.subarray(0, 16));
                    if (this.verbose) {
                        console.log("linea 232: replyId: ", header.replyId, "      command:    ", header.commandId, Object.keys(COMMANDS).find(c => COMMANDS[c] == header.commandId));
                    }
                    // Handle based on command ID
                    if (header.commandId === COMMANDS.CMD_DATA) {
                        // Set a timeout to handle delayed responses
                        timer = setTimeout(() => {
                            internalCallback(replyBuffer); // Resolve with accumulated buffer
                        }, 1000);
                    }
                    else {
                        // Set a timeout to handle errors
                        timer = setTimeout(() => {
                            if (this.socket) {
                                this.socket.removeListener('data', handleOnData); // Clean up listener on timeout
                            }
                            reject(new Error('TIMEOUT_ON_RECEIVING_REQUEST_DATA')); // Reject on timeout
                        }, this.timeout);
                        // Extract packet length and handle accordingly
                        const packetLength = data_3.readUIntLE(4, 2);
                        if (packetLength > 8) {
                            internalCallback(data_3); // Resolve immediately if sufficient data
                        }
                    }
                };
                // Ensure the socket is valid before attaching the listener
                if (this.socket) {
                    this.socket.on('data', handleOnData);
                    // Write the message to the socket
                    this.socket.write(msg, null, (err) => {
                        if (err) {
                            if (this.socket) {
                                this.socket.removeListener('data', handleOnData); // Clean up listener on error
                            }
                            return reject(err); // Reject the promise with the error
                        }
                        // Set a timeout to handle cases where no response is received
                        timer = setTimeout(() => {
                            if (this.socket) {
                                this.socket.removeListener('data', handleOnData); // Clean up listener on timeout
                            }
                            reject(new Error('TIMEOUT_IN_RECEIVING_RESPONSE_AFTER_REQUESTING_DATA')); // Reject on timeout
                        }, this.timeout);
                    });
                }
                else {
                    reject(new Error('SOCKET_NOT_INITIALIZED')); // Reject if socket is not initialized
                }
            });
        }
        catch (err_1) {
            console.error("Promise Rejected:", err_1); // Log the rejection reason
            throw err_1; // Re-throw the error to be handled by the caller
        }
    }
    /**
     *
     * @param {*} command
     * @param {*} data
     *
     *
     * reject error when command fail and resolve data when success
     */
    async executeCmd(command, data) {
        // Reset sessionId and replyId for connection commands
        if (command === COMMANDS.CMD_CONNECT) {
            this.sessionId = 0;
            this.replyId = 0;
        }
        else {
            this.replyId++;
        }
        if (this.verbose) {
            console.log("linea 305: replyId: ", this.replyId, "     command: ", command, Object.keys(COMMANDS).find(u => COMMANDS[u] == command));
        }
        const buf = createTCPHeader(command, this.sessionId, this.replyId, data);
        try {
            // Write the message to the socket and wait for a response
            const reply = await this.writeMessage(buf, command === COMMANDS.CMD_CONNECT || command === COMMANDS.CMD_EXIT);
            // Remove TCP header from the response
            const rReply = removeTcpHeader(reply);
            // Update sessionId for connection command responses
            if (command === COMMANDS.CMD_CONNECT && rReply && rReply.length >= 6) { // Assuming sessionId is located at offset 4 and is 2 bytes long
                this.sessionId = rReply.readUInt16LE(4);
            }
            return rReply;
        }
        catch (err) {
            // Log or handle the error if necessary
            console.error('Error executing command:', err);
            throw err; // Re-throw the error for handling by the caller
        }
    }
    async sendChunkRequest(start, size) {
        this.replyId++;
        const reqData = Buffer.alloc(8);
        reqData.writeUInt32LE(start, 0);
        reqData.writeUInt32LE(size, 4);
        const buf = createTCPHeader(COMMANDS.CMD_DATA_RDY, this.sessionId, this.replyId, reqData);
        try {
            await new Promise((resolve, reject) => {
                this.socket.write(buf, null, (err) => {
                    if (err) {
                        console.error(`[TCP][SEND_CHUNK_REQUEST] Error sending chunk request: ${err.message}`);
                        reject(err); // Reject the promise if there is an error
                    }
                    else {
                        resolve(true); // Resolve the promise if the write operation succeeds
                    }
                });
            });
        }
        catch (err) {
            // Handle or log the error as needed
            console.error(`[TCP][SEND_CHUNK_REQUEST] Exception: ${err.message}`);
            throw err; // Re-throw the error for handling by the caller
        }
    }
    /**
     *
     * @param {*} reqData - indicate the type of data that need to receive ( user or attLog)
     * @param {*} cb - callback is triggered when receiving packets
     *
     * readWithBuffer will reject error if it'wrong when starting request data
     * readWithBuffer will return { data: replyData , err: Error } when receiving requested data
     */
    readWithBuffer(reqData, cb = null) {
        return new Promise(async (resolve, reject) => {
            this.replyId++;
            const buf = createTCPHeader(COMMANDS.CMD_DATA_WRRQ, this.sessionId, this.replyId, reqData);
            let reply = null;
            try {
                reply = await this.requestData(buf);
            }
            catch (err) {
                reject(err);
                console.log(reply);
            }
            const header = decodeTCPHeader(reply.subarray(0, 16));
            switch (header.commandId) {
                case COMMANDS.CMD_DATA: {
                    resolve({ data: reply.subarray(16), mode: 8 });
                    break;
                }
                case COMMANDS.CMD_ACK_OK:
                case COMMANDS.CMD_PREPARE_DATA: {
                    // this case show that data is prepared => send command to get these data
                    // reply variable includes information about the size of following data
                    const recvData = reply.subarray(16);
                    const size = recvData.readUIntLE(1, 4);
                    // We need to split the data to many chunks to receive , because it's to large
                    // After receiving all chunk data , we concat it to TotalBuffer variable , that 's the data we want
                    let remain = size % MAX_CHUNK;
                    let numberChunks = Math.round(size - remain) / MAX_CHUNK;
                    let totalPackets = numberChunks + (remain > 0 ? 1 : 0);
                    let replyData = Buffer.from([]);
                    let totalBuffer = Buffer.from([]);
                    let realTotalBuffer = Buffer.from([]);
                    const timeout = 10000;
                    let timer = setTimeout(() => {
                        internalCallback(replyData, new Error('TIMEOUT WHEN RECEIVING PACKET'));
                    }, timeout);
                    const internalCallback = (replyData, err = null) => {
                        // this.socket && this.socket.removeListener('data', handleOnData)
                        timer && clearTimeout(timer);
                        resolve({ data: replyData, err });
                    };
                    const handleOnData = (reply) => {
                        if (checkNotEventTCP(reply))
                            return;
                        clearTimeout(timer);
                        timer = setTimeout(() => {
                            internalCallback(replyData, new Error(`TIME OUT !! ${totalPackets} PACKETS REMAIN !`));
                        }, timeout);
                        totalBuffer = Buffer.concat([totalBuffer, reply]);
                        const packetLength = totalBuffer.readUIntLE(4, 2);
                        if (totalBuffer.length >= 8 + packetLength) {
                            realTotalBuffer = Buffer.concat([realTotalBuffer, totalBuffer.subarray(16, 8 + packetLength)]);
                            totalBuffer = totalBuffer.subarray(8 + packetLength);
                            if ((totalPackets > 1 && realTotalBuffer.length === MAX_CHUNK + 8)
                                || (totalPackets === 1 && realTotalBuffer.length === remain + 8)) {
                                replyData = Buffer.concat([replyData, realTotalBuffer.subarray(8)]);
                                totalBuffer = Buffer.from([]);
                                realTotalBuffer = Buffer.from([]);
                                totalPackets -= 1;
                                cb && cb(replyData.length, size);
                                if (totalPackets <= 0) {
                                    internalCallback(replyData);
                                }
                            }
                        }
                    };
                    this.socket.once('close', () => {
                        internalCallback(replyData, new Error('Socket is disconnected unexpectedly'));
                    });
                    this.socket.on('data', handleOnData);
                    for (let i = 0; i <= numberChunks; i++) {
                        if (i === numberChunks) {
                            await this.sendChunkRequest(numberChunks * MAX_CHUNK, remain);
                        }
                        else {
                            await this.sendChunkRequest(i * MAX_CHUNK, MAX_CHUNK);
                        }
                    }
                    break;
                }
                default: {
                    reject(new Error('ERROR_IN_UNHANDLE_CMD ' + exportErrorMessage(header.commandId)));
                }
            }
        });
    }
    /**
     *  reject error when starting request data
     *  @return {Record<string, User[] | Error>} when receiving requested data
     */
    async getUsers() {
        try {
            // Free any existing buffer data to prepare for a new request
            if (this.socket) {
                await this.freeData();
            }
            // Request user data
            const data = await this.readWithBuffer(REQUEST_DATA.GET_USERS);
            // Free buffer data after receiving the data
            if (this.socket) {
                await this.freeData();
            }
            // Constants for user data processing
            const USER_PACKET_SIZE = 72;
            // Ensure data.data is a valid buffer
            if (!data.data || !(data.data instanceof Buffer)) {
                throw new Error('Invalid data received');
            }
            let userData = data.data.subarray(4); // Skip the first 4 bytes (headers)
            const users = [];
            // Process each user packet
            while (userData.length >= USER_PACKET_SIZE) {
                // Decode user data and add to the users array
                const user = decodeUserData72(userData.subarray(0, USER_PACKET_SIZE));
                users.push(user);
                userData = userData.subarray(USER_PACKET_SIZE); // Move to the next packet
            }
            // Return the list of users
            return { data: users };
        }
        catch (err) {
            // Log the error for debugging
            console.error('Error getting users:', err);
            // Re-throw the error to be handled by the caller
            throw err;
        }
    }
    /**
     *
     * @param {*} ip
     * @param {*} callbackInProcess
     *  reject error when starting request data
     *  return { data: records, err: Error } when receiving requested data
     */
    async getAttendances(callbackInProcess = () => { }) {
        try {
            // Free any existing buffer data to prepare for a new request
            if (this.socket) {
                await this.freeData();
            }
            // Request attendance logs and handle chunked data
            const data = await this.readWithBuffer(REQUEST_DATA.GET_ATTENDANCE_LOGS, callbackInProcess);
            // Free buffer data after receiving the attendance logs
            if (this.socket) {
                await this.freeData();
            }
            // Constants for record processing
            const RECORD_PACKET_SIZE = 40;
            // Ensure data.data is a valid buffer
            if (!data.data || !(data.data instanceof Buffer)) {
                throw new Error('Invalid data received');
            }
            // Process the record data
            let recordData = data.data.subarray(4); // Skip header
            const records = [];
            // Process each attendance record
            while (recordData.length >= RECORD_PACKET_SIZE) {
                const record = decodeRecordData40(recordData.subarray(0, RECORD_PACKET_SIZE));
                records.push({ ...record, ip: this.ip }); // Add IP address to each record
                recordData = recordData.subarray(RECORD_PACKET_SIZE); // Move to the next packet
            }
            // Return the list of attendance records
            return { data: records };
        }
        catch (err) {
            // Log and re-throw the error
            console.error('Error getting attendance records:', err);
            throw err; // Re-throw the error for handling by the caller
        }
    }
    async freeData() {
        try {
            const resp = await this.executeCmd(COMMANDS.CMD_FREE_DATA, '');
            return !!resp;
        }
        catch (err) {
            console.error('Error freeing data:', err);
            throw err; // Optionally, re-throw the error if you need to handle it upstream
        }
    }
    async disableDevice() {
        try {
            const resp = await this.executeCmd(COMMANDS.CMD_DISABLEDEVICE, REQUEST_DATA.DISABLE_DEVICE);
            return !!resp;
        }
        catch (err) {
            console.error('Error disabling device:', err);
            throw err; // Optionally, re-throw the error if you need to handle it upstream
        }
    }
    async enableDevice() {
        try {
            const resp = await this.executeCmd(COMMANDS.CMD_ENABLEDEVICE, '');
            return !!resp;
        }
        catch (err) {
            console.error('Error enabling device:', err);
            throw err; // Optionally, re-throw the error if you need to handle it upstream
        }
    }
    async disconnect() {
        try {
            // Attempt to execute the disconnect command
            await this.executeCmd(COMMANDS.CMD_EXIT, '');
        }
        catch (err) {
            // Log any errors encountered during command execution
            console.error('Error during disconnection:', err);
            // Optionally, add more handling or recovery logic here
        }
        // Attempt to close the socket and return the result
        try {
            await this.closeSocket();
        }
        catch (err) {
            // Log any errors encountered while closing the socket
            console.error('Error during socket closure:', err);
            // Optionally, rethrow or handle the error if necessary
            throw err; // Re-throwing to propagate the error
        }
    }
    async getInfo() {
        try {
            // Execute the command to retrieve free sizes from the device
            const data = await this.executeCmd(COMMANDS.CMD_GET_FREE_SIZES, '');
            // Parse the response data to extract and return relevant information
            return {
                userCounts: data.readUIntLE(24, 4), // Number of users
                logCounts: data.readUIntLE(40, 4), // Number of logs
                logCapacity: data.readUIntLE(72, 4) // Capacity of logs in bytes
            };
        }
        catch (err) {
            // Log the error for debugging purposes
            console.error('Error getting device info:', err);
            // Re-throw the error to allow upstream error handling
            throw err;
        }
    }
    async getSizes() {
        try {
            // Execute the command to retrieve free sizes from the device
            const data = await this.executeCmd(COMMANDS.CMD_GET_FREE_SIZES, '');
            // Parse the response data to extract and return relevant information
            const buf = data.slice(8); // remove header
            this.user_count = buf.readUIntLE(16, 4);
            this.fp_count = buf.readUIntLE(24, 4);
            this.pwd_count = buf.readUIntLE(52, 4);
            this.oplog_count = buf.readUIntLE(40, 4);
            this.attlog_count = buf.readUIntLE(32, 4);
            this.fp_cap = buf.readUIntLE(56, 4);
            this.user_cap = buf.readUIntLE(60, 4);
            this.attlog_cap = buf.readUIntLE(64, 4);
            this.fp_av = buf.readUIntLE(68, 4);
            this.user_av = buf.readUIntLE(72, 4);
            this.attlog_av = buf.readUIntLE(76, 4);
            this.face_count = buf.readUIntLE(80, 4);
            this.face_cap = buf.readUIntLE(88, 4);
            return {
                userCounts: this.user_count, // Number of users
                logCounts: this.attlog_count, // Number of logs
                fingerCount: this.fp_count,
                adminCount: this.pwd_count,
                opLogCount: this.oplog_count,
                logCapacity: this.attlog_cap, // Capacity of logs in bytes
                fingerCapacity: this.fp_cap,
                userCapacity: this.user_cap,
                attLogCapacity: this.attlog_cap,
                fingerAvailable: this.fp_av,
                userAvailable: this.user_av,
                attLogAvailable: this.attlog_av,
                faceCount: this.face_count,
                faceCapacity: this.face_cap
            };
        }
        catch (err) {
            // Log the error for debugging purposes
            console.error('Error getting device info:', err);
            // Re-throw the error to allow upstream error handling
            throw err;
        }
    }
    async getVendor() {
        const keyword = '~OEMVendor';
        try {
            // Execute the command to get serial number
            const data = await this.executeCmd(COMMANDS.CMD_OPTIONS_RRQ, keyword);
            // Extract and format the serial number from the response data
            const vendor = data.slice(8) // Skip the first 8 bytes (header)
                .toString('ascii') // Convert buffer to string
                .replace(`${keyword}=`, '') // Remove the keyword prefix
                .replace(/\u0000/g, ''); // Remove null characters
            return vendor;
        }
        catch (err) {
            // Log the error for debugging
            console.error('Error getting vendor:', err);
            // Re-throw the error for higher-level handling
            throw err;
        }
    }
    async getProductTime() {
        const keyword = '~ProductTime';
        try {
            // Execute the command to get serial number
            const data = await this.executeCmd(COMMANDS.CMD_OPTIONS_RRQ, keyword);
            // Extract and format the serial number from the response data
            const ProductTime = data.slice(8) // Skip the first 8 bytes (header)
                .toString('ascii') // Convert buffer to string
                .replace(`${keyword}=`, '') // Remove the keyword prefix
                .replace(/\u0000/g, ''); // Remove null characters
            return new Date(ProductTime);
        }
        catch (err) {
            // Log the error for debugging
            console.error('Error getting Product Time:', err);
            // Re-throw the error for higher-level handling
            throw err;
        }
    }
    async getMacAddress() {
        const keyword = 'MAC';
        try {
            // Execute the command to get serial number
            const data = await this.executeCmd(COMMANDS.CMD_OPTIONS_RRQ, keyword);
            // Extract and format the serial number from the response data
            const macAddr = data.slice(8) // Skip the first 8 bytes (header)
                .toString('ascii') // Convert buffer to string
                .replace(`${keyword}=`, '') // Remove the keyword prefix
                .replace(/\u0000/g, ''); // Remove null characters
            return macAddr;
        }
        catch (err) {
            // Log the error for debugging
            console.error('Error getting MAC address:', err);
            // Re-throw the error for higher-level handling
            throw err;
        }
    }
    async getSerialNumber() {
        const keyword = '~SerialNumber';
        try {
            // Execute the command to get serial number
            const data = await this.executeCmd(COMMANDS.CMD_OPTIONS_RRQ, keyword);
            // Extract and format the serial number from the response data
            const serialNumber = data.slice(8) // Skip the first 8 bytes (header)
                .toString('utf-8') // Convert buffer to string
                .replace(`${keyword}=`, '') // Remove the keyword prefix
                .replace(/\u0000/g, ''); // Remove null characters
            return serialNumber;
        }
        catch (err) {
            // Log the error for debugging
            console.error('Error getting serial number:', err);
            // Re-throw the error for higher-level handling
            throw err;
        }
    }
    async getDeviceVersion() {
        const keyword = '~ZKFPVersion';
        try {
            // Execute the command to get device version
            const data = await this.executeCmd(COMMANDS.CMD_OPTIONS_RRQ, keyword);
            // Extract and format the device version from the response data
            // Remove null characters
            return data.slice(8) // Skip the first 8 bytes (header)
                .toString('ascii') // Convert buffer to ASCII string
                .replace(`${keyword}=`, '') // Remove the keyword prefix
                .replace(/\u0000/g, '');
        }
        catch (err) {
            // Log the error for debugging
            console.error('Error getting device version:', err);
            // Re-throw the error for higher-level handling
            throw err;
        }
    }
    async getDeviceName() {
        const keyword = '~DeviceName';
        try {
            // Execute the command to get the device name
            const data = await this.executeCmd(COMMANDS.CMD_OPTIONS_RRQ, keyword);
            // Extract and format the device name from the response data
            // Remove null characters
            return data.slice(8) // Skip the first 8 bytes (header)
                .toString('ascii') // Convert buffer to ASCII string
                .replace(`${keyword}=`, '') // Remove the keyword prefix
                .replace(/\u0000/g, '');
        }
        catch (err) {
            // Log the error for debugging
            console.error('Error getting device name:', err);
            // Re-throw the error for higher-level handling
            throw err;
        }
    }
    async getPlatform() {
        const keyword = '~Platform';
        try {
            // Execute the command to get the platform information
            const data = await this.executeCmd(COMMANDS.CMD_OPTIONS_RRQ, keyword);
            // Extract and format the platform information from the response data
            // Remove null characters
            return data.slice(8) // Skip the first 8 bytes (header)
                .toString('ascii') // Convert buffer to ASCII string
                .replace(`${keyword}=`, '') // Remove the keyword prefix
                .replace(/\u0000/g, '');
        }
        catch (err) {
            // Log the error for debugging
            console.error('Error getting platform information:', err);
            // Re-throw the error for higher-level handling
            throw err;
        }
    }
    async getOS() {
        const keyword = '~OS';
        try {
            // Execute the command to get the OS information
            const data = await this.executeCmd(COMMANDS.CMD_OPTIONS_RRQ, keyword);
            // Extract and format the OS information from the response data
            // Remove null characters
            return data.slice(8) // Skip the first 8 bytes (header)
                .toString('ascii') // Convert buffer to ASCII string
                .replace(`${keyword}=`, '') // Remove the keyword prefix
                .replace(/\u0000/g, '');
        }
        catch (err) {
            // Log the error for debugging
            console.error('Error getting OS information:', err);
            // Re-throw the error for higher-level handling
            throw err;
        }
    }
    async getWorkCode() {
        const keyword = 'WorkCode';
        try {
            // Execute the command to get the WorkCode information
            const data = await this.executeCmd(COMMANDS.CMD_OPTIONS_RRQ, keyword);
            // Extract and format the WorkCode information from the response data
            // Remove null characters
            return data.slice(8) // Skip the first 8 bytes (header)
                .toString('ascii') // Convert buffer to ASCII string
                .replace(`${keyword}=`, '') // Remove the keyword prefix
                .replace(/\u0000/g, '');
        }
        catch (err) {
            // Log the error for debugging
            console.error('Error getting WorkCode:', err);
            // Re-throw the error to be handled by the caller
            throw err;
        }
    }
    async getPIN() {
        const keyword = '~PIN2Width';
        try {
            // Execute the command to get the PIN information
            const data = await this.executeCmd(COMMANDS.CMD_OPTIONS_RRQ, keyword);
            // Extract and format the PIN information from the response data
            // Remove null characters
            return data.slice(8) // Skip the first 8 bytes (header)
                .toString('ascii') // Convert buffer to ASCII string
                .replace(`${keyword}=`, '') // Remove the keyword prefix
                .replace(/\u0000/g, '');
        }
        catch (err) {
            // Log the error for debugging
            console.error('Error getting PIN:', err);
            // Re-throw the error to be handled by the caller
            throw err;
        }
    }
    async getFaceOn() {
        const keyword = 'FaceFunOn';
        try {
            // Execute the command to get the face function status
            const data = await this.executeCmd(COMMANDS.CMD_OPTIONS_RRQ, keyword);
            // Extract and process the status from the response data
            const status = data.slice(8) // Skip the first 8 bytes (header)
                .toString('ascii') // Convert buffer to ASCII string
                .replace(`${keyword}=`, ''); // Remove the keyword prefix
            // Determine and return the face function status
            return status.includes('0') ? 'No' : 'Yes';
        }
        catch (err) {
            // Log the error for debugging
            console.error('Error getting face function status:', err);
            // Re-throw the error to be handled by the caller
            throw err;
        }
    }
    async getSSR() {
        const keyword = '~SSR';
        try {
            // Execute the command to get the SSR value
            const data = await this.executeCmd(COMMANDS.CMD_OPTIONS_RRQ, keyword);
            // Extract and process the SSR value from the response data
            // Remove the keyword prefix
            // Return the SSR value
            return data.slice(8) // Skip the first 8 bytes (header)
                .toString('ascii') // Convert buffer to ASCII string
                .replace(`${keyword}=`, '');
        }
        catch (err) {
            // Log the error for debugging
            console.error('Error getting SSR value:', err);
            // Re-throw the error to be handled by the caller
            throw err;
        }
    }
    async getFirmware() {
        try {
            // Execute the command to get firmware information
            const data = await this.executeCmd(1100, '');
            // Extract and return the firmware version from the response data
            return data.slice(8).toString('ascii'); // Skip the first 8 bytes (header) and convert to ASCII string
        }
        catch (err) {
            // Log the error for debugging
            console.error('Error getting firmware version:', err);
            // Re-throw the error to be handled by the caller
            throw err;
        }
    }
    async getTime() {
        try {
            // Execute the command to get the current time
            const response = await this.executeCmd(COMMANDS.CMD_GET_TIME, '');
            // Check if the response is valid
            if (!response || response.length < 12) {
                throw new Error('Invalid response received for time command');
            }
            // Extract and decode the time value from the response
            const timeValue = response.readUInt32LE(8); // Read 4 bytes starting at offset 8
            return timeParser.decode(timeValue); // Parse and return the decoded time
        }
        catch (err) {
            // Log the error for debugging
            console.error('Error getting time:', err);
            // Re-throw the error for the caller to handle
            throw err;
        }
    }
    async setTime(tm) {
        try {
            // Validate the input time
            if (!(tm instanceof Date) && typeof tm !== 'number') {
                throw new TypeError('Invalid time parameter. Must be a Date object or a timestamp.');
            }
            // Convert the input time to a Date object if it's not already
            const date = (tm instanceof Date) ? tm : new Date(tm);
            // Encode the time into the required format
            const encodedTime = timeParser.encode(date);
            // Create a buffer and write the encoded time
            const commandString = Buffer.alloc(32);
            commandString.writeUInt32LE(encodedTime, 0);
            // Send the command to set the time
            const time = await this.executeCmd(COMMANDS.CMD_SET_TIME, commandString);
            return !!time;
        }
        catch (err) {
            // Log the error for debugging
            console.error('Error setting time:', err);
            // Re-throw the error for the caller to handle
            throw err;
        }
    }
    async voiceTest() {
        try {
            // Define the command data for the voice test
            const commandData = Buffer.from('\x00\x00', 'binary');
            await this.executeCmd(COMMANDS.CMD_TESTVOICE, commandData);
            // Execute the command and return the result
        }
        catch (err) {
            // Log the error for debugging purposes
            console.error('Error executing voice test:', err);
            // Re-throw the error to be handled by the caller
            throw err;
        }
    }
    async setUser(uid, userid, name, password, role = 0, cardno = 0) {
        try {
            // Validate input parameters
            if (uid <= 0 || uid > 3000 ||
                userid.length > 9 ||
                name.length > 24 ||
                password.length > 8 ||
                typeof role !== 'number' ||
                cardno.toString().length > 10) {
                throw new Error('Invalid input parameters');
            }
            // Allocate and initialize the buffer
            const commandBuffer = Buffer.alloc(72);
            // Fill the buffer with user data
            commandBuffer.writeUInt16LE(uid, 0);
            commandBuffer.writeUInt16LE(role, 2);
            commandBuffer.write(password.padEnd(8, '\0'), 3, 8); // Ensure password is 8 bytes
            commandBuffer.write(name.padEnd(24, '\0'), 11, 24); // Ensure name is 24 bytes
            commandBuffer.writeUInt16LE(cardno, 35);
            commandBuffer.writeUInt32LE(0, 40); // Placeholder or reserved field
            commandBuffer.write(userid.padEnd(9, '\0'), 48, 9); // Ensure userid is 9 bytes
            // Send the command and return the result
            const created = await this.executeCmd(COMMANDS.CMD_USER_WRQ, commandBuffer);
            return !!created;
        }
        catch (err) {
            // Log error details for debugging
            console.error('Error setting user:', err);
            // Re-throw error for upstream handling
            throw err;
        }
    }
    async deleteUser(uid) {
        try {
            // Validate input parameter
            if (uid <= 0 || uid > 3000) {
                throw new Error('Invalid UID: must be between 1 and 3000');
            }
            // Allocate and initialize the buffer
            const commandBuffer = Buffer.alloc(72);
            // Write UID to the buffer
            commandBuffer.writeUInt16LE(uid, 0);
            // Send the delete command and return the result
            const deleted = await this.executeCmd(COMMANDS.CMD_DELETE_USER, commandBuffer);
            return !!deleted;
        }
        catch (err) {
            // Log error details for debugging
            console.error('Error deleting user:', err);
            // Re-throw error for upstream handling
            throw err;
        }
    }
    async getAttendanceSize() {
        try {
            // Execute command to get free sizes
            const data = await this.executeCmd(COMMANDS.CMD_GET_FREE_SIZES, '');
            // Parse and return the attendance size
            return data.readUIntLE(40, 4); // Assuming data at offset 40 represents the attendance size
        }
        catch (err) {
            // Log error details for debugging
            console.error('Error getting attendance size:', err);
            // Re-throw the error to be handled by the caller
            throw err;
        }
    }
    // Clears the attendance logs on the device
    async clearAttendanceLog() {
        try {
            // Execute the command to clear attendance logs
            return await this.executeCmd(COMMANDS.CMD_CLEAR_ATTLOG, '');
        }
        catch (err) {
            // Log the error for debugging purposes
            console.error('Error clearing attendance log:', err);
            // Re-throw the error to be handled by the caller
            throw err;
        }
    }
    // Clears all data on the device
    async clearData() {
        try {
            // Execute the command to clear all data
            return await this.executeCmd(COMMANDS.CMD_CLEAR_DATA, '');
        }
        catch (err) {
            // Log the error for debugging purposes
            console.error('Error clearing data:', err);
            // Re-throw the error to be handled by the caller
            throw err;
        }
    }
    async getRealTimeLogs(cb = (realTimeLog) => { }) {
        this.replyId++; // Increment the reply ID for this request
        try {
            // Create a buffer with the command header to request real-time logs
            const buf = createTCPHeader(COMMANDS.CMD_REG_EVENT, this.sessionId, this.replyId, Buffer.from([0x01, 0x00, 0x00, 0x00]));
            // Send the request to the device
            this.socket.write(buf, null, (err) => {
                if (err) {
                    // Log and reject the promise if there is an error writing to the socket
                    console.error('Error sending real-time logs request:', err);
                    throw err;
                }
            });
            // Ensure data listeners are added only once
            if (this.socket.listenerCount('data') === 0) {
                this.socket.on('data', (data) => {
                    // Check if the data is an event and not just a regular response
                    if (checkNotEventTCP(data)) {
                        // Process the data if it is of the expected length
                        if (data.length > 16) {
                            // Decode and pass the log to the callback
                            cb(decodeRecordRealTimeLog52(data));
                        }
                    }
                });
            }
        }
        catch (err) {
            // Handle errors and reject the promise
            console.error('Error getting real-time logs:', err);
            throw err;
        }
    }
    async getTemplates() {
        try {
            await this.freeData();
            await this.disableDevice();
            const Buffer = await this.readWithBuffer(REQUEST_DATA.GET_TEMPLATES);
            let templateData = Buffer.data.slice(4);
            let totalSize = Buffer.data.readUIntLE(0, 4);
            let templates = [];
            while (totalSize) {
                const buf = templateData.slice(0, 6);
                const size = buf.readUIntLE(0, 2);
                templates.push(new Finger(buf.readUIntLE(2, 2), buf.readUIntLE(4, 1), buf.readUIntLE(5, 1), templateData.slice(6, size)));
                templateData = templateData.slice(size);
                totalSize -= size;
            }
            return templates;
        }
        catch (err) {
            console.error('Error getting user templates: ', err);
            throw err;
        }
        finally {
            await this.enableDevice();
            await this.freeData();
        }
    }
    async refreshData() {
        try {
            const reply = await this.executeCmd(COMMANDS.CMD_REFRESHDATA, '');
            return !!reply;
        }
        catch (err) {
            console.error('Error getting user templates: ', err);
            throw err;
        }
    }
    async sendWithBuffer(buffer) {
        const MAX_CHUNK = 1024;
        const size = buffer.length;
        await this.freeData();
        const commandString = Buffer.alloc(4); // 'I' is 4 bytes
        commandString.writeUInt32LE(size, 0);
        try {
            const cmdResponse = await this.executeCmd(COMMANDS.CMD_PREPARE_DATA, commandString);
            // responds with 2000 = CMD_ACK_OK
            if (!cmdResponse) {
                throw new Error("Can't prepare data");
            }
        }
        catch (e) {
            console.error(e);
        }
        const remain = size % MAX_CHUNK;
        const packets = Math.floor((size - remain) / MAX_CHUNK);
        let start = 0;
        try {
            for (let i = 0; i < packets; i++) {
                const resp = await this.sendChunk(buffer.slice(start, start + MAX_CHUNK));
                if (resp) {
                    start += MAX_CHUNK;
                    if (i == packets - 1 && remain) {
                        const lastPacket = await this.sendChunk(buffer.slice(start, start + remain));
                        return lastPacket;
                    }
                }
            }
        }
        catch (e) {
            console.error(e);
        }
    }
    async sendChunk(commandString) {
        try {
            return await new Promise((resolve, reject) => {
                resolve(this.executeCmd(COMMANDS.CMD_DATA, commandString));
            });
        }
        catch (e) {
            throw new ZkError(e, COMMANDS.CMD_DATA, this.ip);
        }
    }
    /**
     * save user and template
     *
     * @param {User | number | string} user - User class object | uid | user_id
     * @param {Finger[]} fingers - Array of finger class. `0 <= index <= 9`
     */
    async saveUserTemplate(user, fingers = []) {
        if (fingers.length > 9 || fingers.length == 0)
            throw new Error("maximum finger length is 10 and can't be empty");
        try {
            await this.disableDevice();
            const users = await this.getUsers();
            //check users exists
            if (!users.data.some(u => u.uid == user.uid || +u.user_id == +user.user_id))
                throw new Error("error validating user input");
            if (!(user instanceof User)) {
                let tusers = users.data.filter(x => x.uid === +user.uid);
                if (tusers.length === 1) {
                    user = tusers[0];
                }
                else {
                    tusers = users.data.filter(x => x.user_id === String(user));
                    if (tusers.length === 1) {
                        user = tusers[0];
                    }
                    else {
                        throw new Error("Can't find user");
                    }
                }
            }
            if (fingers instanceof Finger) {
                fingers = [fingers];
            }
            let fpack = Buffer.alloc(0);
            let table = Buffer.alloc(0);
            const fnum = 0x10;
            let tstart = 0;
            for (const finger of fingers) {
                const tfp = finger.repackOnly();
                const tableEntry = Buffer.alloc(11); // b=1, H=2, b=1, I=4 => 1+2+1+4=8? Wait, bHbI is 1+2+1+4=8 bytes
                tableEntry.writeInt8(2, 0);
                tableEntry.writeUInt16LE(user.uid, 1);
                tableEntry.writeInt8(fnum + finger.fid, 3);
                tableEntry.writeUInt32LE(tstart, 4);
                table = Buffer.concat([table, tableEntry]);
                tstart += tfp.length;
                fpack = Buffer.concat([fpack, tfp]);
            }
            let upack;
            if (this.userPacketSize === 28) {
                upack = user.repack29();
            }
            else {
                upack = user.repack73();
            }
            const head = Buffer.alloc(12); // III = 3*4 bytes
            head.writeUInt32LE(upack.length, 0);
            head.writeUInt32LE(table.length, 4);
            head.writeUInt32LE(fpack.length, 8);
            const packet = Buffer.concat([head, upack, table, fpack]);
            const bufferResponse = await this.sendWithBuffer(packet);
            const command = 110;
            const commandString = Buffer.alloc(8); // <IHH = I(4) + H(2) + H(2) = 8 bytes
            commandString.writeUInt32LE(12, 0);
            commandString.writeUInt16LE(0, 4);
            commandString.writeUInt16LE(8, 6);
            const cmdResponse = await this.executeCmd(command, commandString);
            if (this.verbose)
                console.log("finally bulk save user templates: \n", cmdResponse.readUInt16LE(0));
        }
        catch (error) {
            throw error;
        }
        finally {
            await this.refreshData();
            await this.enableDevice();
        }
    }
    async deleteFinger(uid, fid) {
        try {
            const buf = Buffer.alloc(4);
            buf.writeUInt16LE(uid, 0);
            buf.writeUint16LE(fid, 2);
            const reply = await this.executeCmd(COMMANDS.CMD_DELETE_USERTEMP, buf);
            return !!reply;
        }
        catch (error) {
            throw new Error("Can't save utemp");
        }
        finally {
            await this.refreshData();
        }
    }
    async enrollUser(uid, tempId, userId = '') {
        let done = false;
        try {
            //validate user exists
            const users = await this.getUsers();
            const filteredUsers = users.data.filter(x => x.uid === uid);
            if (filteredUsers.length >= 1) {
                userId = filteredUsers[0].user_id;
            }
            else {
                throw new Error("user not found");
            }
            const userBuf = Buffer.alloc(24);
            userBuf.write(userId.toString(), 0, 24, 'ascii');
            let commandString = Buffer.concat([
                userBuf,
                Buffer.from([tempId, 1])
            ]);
            const cancel = await this.cancelCapture();
            const cmdResponse = await this.executeCmd(COMMANDS.CMD_STARTENROLL, commandString);
            this.timeout = 60000; // 60 seconds timeout
            let attempts = 3;
            while (attempts > 0) {
                if (this.verbose)
                    console.log(`A:${attempts} esperando primer regevent`);
                let dataRecv = await this.readSocket(17);
                await this.ackOk();
                if (dataRecv.length > 16) {
                    const padded = Buffer.concat([dataRecv, Buffer.alloc(24 - dataRecv.length)]);
                    const res = padded.readUInt16LE(16);
                    if (this.verbose)
                        console.log(`res ${res}`);
                    if (res === 0 || res === 6 || res === 4) {
                        if (this.verbose)
                            console.log("posible timeout o reg Fallido");
                        break;
                    }
                }
                if (this.verbose)
                    console.log(`A:${attempts} esperando 2do regevent`);
                dataRecv = await this.readSocket(17);
                await this.ackOk();
                if (this.verbose)
                    console.log(dataRecv);
                if (dataRecv.length > 8) {
                    const padded = Buffer.concat([dataRecv, Buffer.alloc(24 - dataRecv.length)]);
                    const res = padded.readUInt16LE(16);
                    if (this.verbose)
                        console.log(`res ${res}`);
                    if (res === 6 || res === 4) {
                        if (this.verbose)
                            console.log("posible timeout o reg Fallido");
                        break;
                    }
                    else if (res === 0x64) {
                        if (this.verbose)
                            console.log("ok, continue?");
                        attempts--;
                    }
                }
            }
            if (attempts === 0) {
                const dataRecv = await this.readSocket(17);
                await this.ackOk();
                if (this.verbose)
                    console.log(dataRecv.toString('hex'));
                const padded = Buffer.concat([dataRecv, Buffer.alloc(24 - dataRecv.length)]);
                let res = padded.readUInt16LE(16);
                if (this.verbose)
                    console.log(`res ${res}`);
                if (res === 5) {
                    if (this.verbose)
                        console.log("finger duplicate");
                }
                if (res === 6 || res === 4) {
                    if (this.verbose)
                        console.log("posible timeout");
                }
                if (res === 0) {
                    const size = padded.readUInt16LE(10);
                    const pos = padded.readUInt16LE(12);
                    if (this.verbose)
                        console.log(`enroll ok ${size} ${pos}`);
                    done = true;
                }
            }
            //this.__sock.setTimeout(this.__timeout);
            await this.regEvent(0); // TODO: test
            return done;
        }
        catch (error) {
            throw error;
        }
        finally {
            await this.cancelCapture();
            await this.verifyUser(undefined);
        }
    }
    async readSocket(length, cb = null) {
        let replyBufer = Buffer.from([]);
        let totalPackets = 0;
        return new Promise((resolve, reject) => {
            let timer = setTimeout(() => {
                internalCallback(replyBufer, new Error('TIMEOUT WHEN RECEIVING PACKET'));
            }, this.timeout);
            const internalCallback = (replyData, err = null) => {
                this.socket && this.socket.removeListener('data', onDataEnroll);
                timer && clearTimeout(timer);
                resolve({ data: replyData, err: err });
            };
            function onDataEnroll(data) {
                clearTimeout(timer);
                timer = setTimeout(() => {
                    internalCallback(replyBufer, new Error(`TIME OUT !! ${totalPackets} PACKETS REMAIN !`));
                }, this.timeout);
                replyBufer = Buffer.concat([replyBufer, data], replyBufer.length + data.length);
                if (data.length == length) {
                    internalCallback(data);
                }
            }
            this.socket.once('close', () => {
                internalCallback(replyBufer, new Error('Socket is disconnected unexpectedly'));
            });
            this.socket.on('data', onDataEnroll);
        }).catch((err) => {
            console.error("Promise Rejected:", err); // Log the rejection reason
            throw err; // Re-throw the error to be handled by the caller
        });
    }
    /**
     * Register events
     * @param {number} flags - Event flags
     * @returns {Promise<void>}
     * @throws {ZKErrorResponse} If registration fails
     */
    async regEvent(flags) {
        try {
            const commandString = Buffer.alloc(4); // 'I' format is 4 bytes
            commandString.writeUInt32LE(flags, 0); // Little-endian unsigned int
            const cmdResponse = await this.executeCmd(COMMANDS.CMD_REG_EVENT, commandString);
            if (this.verbose)
                console.log("regEvent: ", cmdResponse.readUInt16LE(0));
        }
        catch (e) {
            throw new ZkError(e, COMMANDS.CMD_REG_EVENT, this.ip);
        }
    }
    async ackOk() {
        try {
            const buf = createTCPHeader(COMMANDS.CMD_ACK_OK, this.sessionId, USHRT_MAX - 1, Buffer.from([]));
            this.socket.write(buf);
        }
        catch (e) {
            throw new ZkError(e, COMMANDS.CMD_ACK_OK, this.ip);
        }
    }
    async cancelCapture() {
        try {
            const reply = await this.executeCmd(COMMANDS.CMD_CANCELCAPTURE, '');
            return !!reply;
        }
        catch (e) {
            throw new ZkError(e, COMMANDS.CMD_CANCELCAPTURE, this.ip);
        }
    }
    async verifyUser(uid) {
        try {
            let command_string = '';
            if (uid) {
                command_string = Buffer.alloc(4);
                command_string.writeUInt32LE(uid, 0);
            }
            const reply = await this.executeCmd(COMMANDS.CMD_STARTVERIFY, command_string);
            if (this.verbose)
                console.log(reply.readUInt16LE(0));
            return !!reply;
        }
        catch (error) {
            console.error(error);
        }
    }
    async restartDevice() {
        try {
            await this.executeCmd(COMMANDS.CMD_RESTART, '');
        }
        catch (e) {
            throw new ZkError(e, COMMANDS.CMD_RESTART, this.ip);
        }
    }
}

class ZUDP {
    ip;
    port;
    timeout;
    socket;
    sessionId;
    replyId;
    inport;
    comm_key;
    constructor(ip, port, timeout, inport, comm_key = 0) {
        this.ip = ip;
        this.port = port;
        this.timeout = timeout;
        this.socket = null;
        this.sessionId = null;
        this.replyId = 0;
        this.inport = inport;
        this.comm_key = comm_key;
    }
    createSocket(cbError, cbClose) {
        return new Promise((resolve, reject) => {
            this.socket = dgram__namespace.createSocket('udp4');
            this.socket.setMaxListeners(Infinity);
            this.socket.once('error', (err) => {
                this.socket = null;
                reject(err);
                if (cbError)
                    cbError(err);
            });
            this.socket.once('close', () => {
                this.socket = null;
                if (cbClose)
                    cbClose('udp');
            });
            this.socket.once('listening', () => {
                resolve(this.socket);
            });
            try {
                this.socket.bind(this.inport);
            }
            catch (err) {
                this.socket = null;
                reject(err);
                if (cbError)
                    cbError(err);
            }
        });
    }
    async connect() {
        try {
            let reply = await this.executeCmd(COMMANDS.CMD_CONNECT, '');
            if (reply.readUInt16LE(0) === COMMANDS.CMD_ACK_OK) {
                return true;
            }
            if (reply.readUInt16LE(0) === COMMANDS.CMD_ACK_UNAUTH) {
                const hashedCommkey = authKey(this.comm_key, this.sessionId);
                reply = await this.executeCmd(COMMANDS.CMD_AUTH, hashedCommkey);
                if (reply.readUInt16LE(0) === COMMANDS.CMD_ACK_OK) {
                    return true;
                }
                else {
                    throw new Error("Authentication error");
                }
            }
            else {
                throw new Error('NO_REPLY_ON_CMD_CONNECT');
            }
        }
        catch (err) {
            console.error('Error in connect method:', err);
            throw err;
        }
    }
    async closeSocket() {
        return new Promise((resolve, reject) => {
            if (!this.socket) {
                resolve(true);
                return;
            }
            const timeout = 2000;
            const timer = setTimeout(() => {
                console.warn('Socket close timeout');
                resolve(true);
            }, timeout);
            this.socket.removeAllListeners('message');
            // @ts-ignore
            this.socket.close((err) => {
                clearTimeout(timer);
                if (err) {
                    console.error('Error closing socket:', err);
                    reject(err);
                }
                else {
                    resolve(true);
                }
                this.socket = null;
            });
        });
    }
    writeMessage(msg, connect) {
        return new Promise((resolve, reject) => {
            if (!this.socket) {
                reject(new Error('Socket not initialized'));
                return;
            }
            let sendTimeoutId;
            const onMessage = (data) => {
                clearTimeout(sendTimeoutId);
                this.socket.removeListener('message', onMessage);
                resolve(data);
            };
            this.socket.once('message', onMessage);
            this.socket.send(msg, 0, msg.length, this.port, this.ip, (err) => {
                if (err) {
                    this.socket.removeListener('message', onMessage);
                    reject(err);
                    return;
                }
                if (this.timeout) {
                    sendTimeoutId = setTimeout(() => {
                        this.socket.removeListener('message', onMessage);
                        reject(new Error('TIMEOUT_ON_WRITING_MESSAGE'));
                    }, connect ? 2000 : this.timeout);
                }
            });
        });
    }
    requestData(msg) {
        return new Promise((resolve, reject) => {
            if (!this.socket) {
                reject(new Error('Socket not initialized'));
                return;
            }
            let sendTimeoutId;
            let responseTimeoutId;
            const handleOnData = (data) => {
                if (checkNotEventUDP(data))
                    return;
                clearTimeout(sendTimeoutId);
                clearTimeout(responseTimeoutId);
                this.socket.removeListener('message', handleOnData);
                resolve(data);
            };
            const onReceiveTimeout = () => {
                this.socket.removeListener('message', handleOnData);
                reject(new Error('TIMEOUT_ON_RECEIVING_REQUEST_DATA'));
            };
            this.socket.on('message', handleOnData);
            this.socket.send(msg, 0, msg.length, this.port, this.ip, (err) => {
                if (err) {
                    this.socket.removeListener('message', handleOnData);
                    reject(err);
                    return;
                }
                responseTimeoutId = setTimeout(onReceiveTimeout, this.timeout);
            });
            sendTimeoutId = setTimeout(() => {
                this.socket.removeListener('message', handleOnData);
                reject(new Error('TIMEOUT_IN_RECEIVING_RESPONSE_AFTER_REQUESTING_DATA'));
            }, this.timeout);
        });
    }
    async executeCmd(command, data) {
        try {
            if (command === COMMANDS.CMD_CONNECT) {
                this.sessionId = 0;
                this.replyId = 0;
            }
            else {
                this.replyId++;
            }
            const buf = createUDPHeader(command, this.sessionId, this.replyId, data);
            const reply = await this.writeMessage(buf, command === COMMANDS.CMD_CONNECT || command === COMMANDS.CMD_EXIT);
            if (reply && reply.length > 0) {
                if (command === COMMANDS.CMD_CONNECT) {
                    this.sessionId = reply.readUInt16LE(4);
                }
            }
            return reply;
        }
        catch (err) {
            console.error(`Error executing command ${command}:`, err);
            throw err;
        }
    }
    async sendChunkRequest(start, size) {
        this.replyId++;
        const reqData = Buffer.alloc(8);
        reqData.writeUInt32LE(start, 0);
        reqData.writeUInt32LE(size, 4);
        const buf = createUDPHeader(COMMANDS.CMD_DATA_RDY, this.sessionId, this.replyId, reqData);
        try {
            await new Promise((resolve, reject) => {
                this.socket.send(buf, 0, buf.length, this.port, this.ip, (err) => {
                    if (err) {
                        log(`[UDP][SEND_CHUNK_REQUEST] Error sending chunk request: ${err.message}`);
                        reject(err);
                    }
                    else {
                        resolve();
                    }
                });
            });
        }
        catch (error) {
            log(`[UDP][SEND_CHUNK_REQUEST] Exception: ${error.message}`);
            throw error;
        }
    }
    async readWithBuffer(reqData, cb = null) {
        this.replyId++;
        const buf = createUDPHeader(COMMANDS.CMD_DATA_WRRQ, this.sessionId, this.replyId, reqData);
        try {
            const reply = await this.requestData(buf);
            const header = decodeUDPHeader(reply.subarray(0, 8));
            switch (header.commandId) {
                case COMMANDS.CMD_DATA:
                    return { data: reply.subarray(8), err: null };
                case COMMANDS.CMD_ACK_OK:
                case COMMANDS.CMD_PREPARE_DATA:
                    return await this.handleChunkedData(reply, header.commandId, cb);
                default:
                    throw new Error('ERROR_IN_UNHANDLE_CMD ' + exportErrorMessage(header.commandId));
            }
        }
        catch (err) {
            return { data: null, err: err };
        }
    }
    async handleChunkedData(reply, commandId, cb) {
        return new Promise((resolve) => {
            const recvData = reply.subarray(8);
            const size = recvData.readUIntLE(1, 4);
            let totalBuffer = Buffer.from([]);
            const timeout = 3000;
            let timer = setTimeout(() => {
                this.socket.removeListener('message', handleOnData);
                resolve({ data: null, err: new Error('TIMEOUT WHEN RECEIVING PACKET') });
            }, timeout);
            const internalCallback = (replyData, err = null) => {
                this.socket.removeListener('message', handleOnData);
                clearTimeout(timer);
                resolve({ data: err ? null : replyData, err });
            };
            const handleOnData = (reply) => {
                if (checkNotEventUDP(reply))
                    return;
                clearTimeout(timer);
                timer = setTimeout(() => {
                    internalCallback(totalBuffer, new Error(`TIMEOUT !! ${(size - totalBuffer.length) / size} % REMAIN !`));
                }, timeout);
                const header = decodeUDPHeader(reply);
                switch (header.commandId) {
                    case COMMANDS.CMD_PREPARE_DATA:
                        break;
                    case COMMANDS.CMD_DATA:
                        totalBuffer = Buffer.concat([totalBuffer, reply.subarray(8)]);
                        cb && cb(totalBuffer.length, size);
                        break;
                    case COMMANDS.CMD_ACK_OK:
                        if (totalBuffer.length === size) {
                            internalCallback(totalBuffer);
                        }
                        break;
                    default:
                        internalCallback(Buffer.from([]), new Error('ERROR_IN_UNHANDLE_CMD ' + exportErrorMessage(header.commandId)));
                }
            };
            this.socket.on('message', handleOnData);
            const chunkCount = Math.ceil(size / MAX_CHUNK);
            for (let i = 0; i < chunkCount; i++) {
                const start = i * MAX_CHUNK;
                const chunkSize = (i === chunkCount - 1) ? size % MAX_CHUNK : MAX_CHUNK;
                this.sendChunkRequest(start, chunkSize).catch(err => {
                    internalCallback(Buffer.from([]), err);
                });
            }
        });
    }
    async getUsers() {
        try {
            if (this.socket) {
                await this.freeData();
            }
            const data = await this.readWithBuffer(REQUEST_DATA.GET_USERS);
            if (this.socket) {
                await this.freeData();
            }
            const USER_PACKET_SIZE = 28;
            let userData = data.data?.subarray(4) || Buffer.from([]);
            const users = [];
            while (userData.length >= USER_PACKET_SIZE) {
                const user = decodeUserData28(userData.subarray(0, USER_PACKET_SIZE));
                users.push(user);
                userData = userData.subarray(USER_PACKET_SIZE);
            }
            return { data: users };
        }
        catch (err) {
            throw new Error(err.message);
        }
    }
    async getAttendances(callbackInProcess) {
        try {
            if (this.socket) {
                await this.freeData();
            }
            const data = await this.readWithBuffer(REQUEST_DATA.GET_ATTENDANCE_LOGS);
            if (this.socket) {
                await this.freeData();
            }
            const RECORD_PACKET_SIZE = 16;
            let recordData = data.data?.subarray(4) || Buffer.from([]);
            const records = [];
            while (recordData.length >= RECORD_PACKET_SIZE) {
                const record = decodeRecordData16(recordData.subarray(0, RECORD_PACKET_SIZE));
                records.push({ ...record, ip: this.ip });
                recordData = recordData.subarray(RECORD_PACKET_SIZE);
            }
            return { data: records, err: data.err };
        }
        catch (err) {
            return { data: [], err: err };
        }
    }
    async freeData() {
        try {
            const resp = await this.executeCmd(COMMANDS.CMD_FREE_DATA, Buffer.alloc(0));
            return !!resp;
        }
        catch (err) {
            console.error('Error freeing data:', err);
            throw err;
        }
    }
    async getInfo() {
        try {
            const data = await this.executeCmd(COMMANDS.CMD_GET_FREE_SIZES, Buffer.alloc(0));
            return {
                userCounts: data.readUIntLE(24, 4),
                logCounts: data.readUIntLE(40, 4),
                logCapacity: data.readUIntLE(72, 4)
            };
        }
        catch (err) {
            console.error('Error retrieving info:', err);
            throw err;
        }
    }
    async getTime() {
        try {
            const response = await this.executeCmd(COMMANDS.CMD_GET_TIME, Buffer.alloc(0));
            const timeValue = response.readUInt32LE(8);
            return timeParser.decode(timeValue);
        }
        catch (err) {
            console.error('Error retrieving time:', err);
            throw err;
        }
    }
    async setTime(tm) {
        try {
            const commandBuffer = Buffer.alloc(32);
            commandBuffer.writeUInt32LE(timeParser.encode(new Date(tm)), 0);
            await this.executeCmd(COMMANDS.CMD_SET_TIME, commandBuffer);
            return true;
        }
        catch (err) {
            console.error('Error setting time:', err);
            throw err;
        }
    }
    async clearAttendanceLog() {
        try {
            return await this.executeCmd(COMMANDS.CMD_CLEAR_ATTLOG, Buffer.alloc(0));
        }
        catch (err) {
            console.error('Error clearing attendance log:', err);
            throw err;
        }
    }
    async clearData() {
        try {
            return await this.executeCmd(COMMANDS.CMD_CLEAR_DATA, Buffer.alloc(0));
        }
        catch (err) {
            console.error('Error clearing data:', err);
            throw err;
        }
    }
    async disableDevice() {
        try {
            const resp = await this.executeCmd(COMMANDS.CMD_DISABLEDEVICE, REQUEST_DATA.DISABLE_DEVICE);
            return !!resp;
        }
        catch (err) {
            console.error('Error disabling device:', err);
            throw err;
        }
    }
    async enableDevice() {
        try {
            const resp = await this.executeCmd(COMMANDS.CMD_ENABLEDEVICE, Buffer.alloc(0));
            return !!resp;
        }
        catch (err) {
            console.error('Error enabling device:', err);
            throw err;
        }
    }
    async disconnect() {
        try {
            await this.executeCmd(COMMANDS.CMD_EXIT, Buffer.alloc(0));
        }
        catch (err) {
            console.error('Error executing disconnect command:', err);
        }
        try {
            await this.closeSocket();
        }
        catch (err) {
            console.error('Error closing the socket:', err);
        }
    }
    async getRealTimeLogs(cb = () => { }) {
        this.replyId++;
        const buf = createUDPHeader(COMMANDS.CMD_REG_EVENT, this.sessionId, this.replyId, REQUEST_DATA.GET_REAL_TIME_EVENT);
        try {
            this.socket.send(buf, 0, buf.length, this.port, this.ip, (err) => {
                if (err) {
                    console.error('Error sending UDP message:', err);
                    return;
                }
                console.log('UDP message sent successfully');
            });
        }
        catch (err) {
            console.error('Error during send operation:', err);
            return;
        }
        const handleMessage = (data) => {
            if (!checkNotEventUDP(data))
                return;
            if (data.length === 18) {
                cb(decodeRecordRealTimeLog18(data));
            }
        };
        if (this.socket.listenerCount('message') === 0) {
            this.socket.on('message', handleMessage);
        }
        else {
            console.warn('Multiple message listeners detected. Ensure only one listener is attached.');
        }
    }
}

class Zklib {
    set connectionType(value) {
        this._connectionType = value;
    }
    _connectionType = null;
    ztcp;
    zudp;
    interval = null;
    timer = null;
    isBusy = false;
    ip;
    comm_key;
    get connectionType() {
        return this._connectionType;
    }
    /**
     * Creates a new Zkteco device connection instance
     * @param ip IP address of device
     * @param port Port number of device
     * @param timeout Connection timeout in milliseconds
     * @param inport Required only for UDP connection (default: 10000)
     * @param comm_key Communication key of device (default: 0)
     * @param verbose Console log some data
     */
    constructor(ip, port = 4370, timeout = 5000, inport = 10000, comm_key = 0, verbose = false) {
        this.ip = ip;
        this.comm_key = comm_key;
        this.ztcp = new ZTCP(ip, port, timeout, comm_key, verbose);
        this.zudp = new ZUDP(ip, port, timeout, inport);
    }
    async functionWrapper(tcpCallback, udpCallback, command) {
        try {
            switch (this._connectionType) {
                case 'tcp':
                    if (this.ztcp && this.ztcp.socket) {
                        return await tcpCallback();
                    }
                    else {
                        throw new ZkError(new Error(`TCP socket isn't connected!`), `[TCP] ${command}`, this.ip);
                    }
                case 'udp':
                    if (this.zudp && this.zudp.socket) {
                        return await udpCallback();
                    }
                    else {
                        throw new ZkError(new Error(`UDP socket isn't connected!`), `[UDP] ${command}`, this.ip);
                    }
                default:
                    throw new ZkError(new Error(`Unsupported connection type or socket isn't connected!`), '', this.ip);
            }
        }
        catch (err) {
            throw new ZkError(err, `[${this._connectionType?.toUpperCase()}] ${command}`, this.ip);
        }
    }
    async createSocket(cbErr, cbClose) {
        try {
            if (this.ztcp.socket) {
                try {
                    await this.ztcp.connect();
                    console.log('TCP reconnection successful');
                    this._connectionType = 'tcp';
                    return true;
                }
                catch (err) {
                    throw new ZkError(err, 'TCP CONNECT', this.ip);
                }
            }
            else {
                try {
                    await this.ztcp.createSocket(cbErr, cbClose);
                    await this.ztcp.connect();
                    console.log('TCP connection successful');
                    this._connectionType = 'tcp';
                    return true;
                }
                catch (err) {
                    throw new ZkError(err, 'TCP CONNECT', this.ip);
                }
            }
        }
        catch (err) {
            try {
                if (this.ztcp.socket)
                    await this.ztcp.disconnect();
            }
            catch (disconnectErr) {
                console.error('Error disconnecting TCP:', disconnectErr);
            }
            if (err.code !== ERROR_TYPES.ECONNREFUSED) {
                throw new ZkError(err, 'TCP CONNECT', this.ip);
            }
            try {
                if (!this.zudp.socket) {
                    await this.zudp.createSocket(cbErr, cbClose);
                }
                await this.zudp.connect();
                console.log('UDP connection successful');
                this._connectionType = 'udp';
                return true;
            }
            catch (err) {
                if (err.message !== 'EADDRINUSE') {
                    this._connectionType = null;
                    try {
                        await this.zudp.disconnect();
                    }
                    catch (disconnectErr) {
                        console.error('Error disconnecting UDP:', disconnectErr);
                    }
                    throw new ZkError(err, 'UDP CONNECT', this.ip);
                }
                this._connectionType = 'udp';
                return true;
            }
        }
    }
    async getUsers() {
        return this.functionWrapper(() => this.ztcp.getUsers(), () => this.zudp.getUsers(), 'GET_USERS');
    }
    async getTime() {
        return this.functionWrapper(() => this.ztcp.getTime(), () => this.zudp.getTime(), 'GET_TIME');
    }
    async setTime(t) {
        return this.functionWrapper(() => this.ztcp.setTime(t), () => this.zudp.setTime(t), 'SET_TIME');
    }
    async voiceTest() {
        return this.functionWrapper(() => this.ztcp.voiceTest(), async () => { throw new Error('UDP voice test not supported'); }, 'VOICE_TEST');
    }
    async getProductTime() {
        return this.functionWrapper(() => this.ztcp.getProductTime(), async () => { throw new Error('UDP get product time not supported'); }, 'GET_PRODUCT_TIME');
    }
    async getVendor() {
        return this.functionWrapper(() => this.ztcp.getVendor(), async () => { throw new Error('UDP get vendor not supported'); }, 'GET_VENDOR');
    }
    async getMacAddress() {
        return this.functionWrapper(() => this.ztcp.getMacAddress(), async () => { throw new Error('UDP get MAC address not supported'); }, 'GET_MAC_ADDRESS');
    }
    async getSerialNumber() {
        return this.functionWrapper(() => this.ztcp.getSerialNumber(), async () => { throw new Error('UDP get serial number not supported'); }, 'GET_SERIAL_NUMBER');
    }
    async getDeviceVersion() {
        return this.functionWrapper(() => this.ztcp.getDeviceVersion(), async () => { throw new Error('UDP get device version not supported'); }, 'GET_DEVICE_VERSION');
    }
    async getDeviceName() {
        return this.functionWrapper(() => this.ztcp.getDeviceName(), async () => { throw new Error('UDP get device name not supported'); }, 'GET_DEVICE_NAME');
    }
    async getPlatform() {
        return this.functionWrapper(() => this.ztcp.getPlatform(), async () => { throw new Error('UDP get platform not supported'); }, 'GET_PLATFORM');
    }
    async getOS() {
        return this.functionWrapper(() => this.ztcp.getOS(), async () => { throw new Error('UDP get OS not supported'); }, 'GET_OS');
    }
    async getWorkCode() {
        return this.functionWrapper(() => this.ztcp.getWorkCode(), async () => { throw new Error('UDP get work code not supported'); }, 'GET_WORK_CODE');
    }
    async getPIN() {
        return this.functionWrapper(() => this.ztcp.getPIN(), async () => { throw new Error('UDP get PIN not supported'); }, 'GET_PIN');
    }
    async getFaceOn() {
        return this.functionWrapper(() => this.ztcp.getFaceOn(), async () => { throw new Error('UDP get face on not supported'); }, 'GET_FACE_ON');
    }
    async getSSR() {
        return this.functionWrapper(() => this.ztcp.getSSR(), async () => { throw new Error('UDP get SSR not supported'); }, 'GET_SSR');
    }
    async getFirmware() {
        return this.functionWrapper(() => this.ztcp.getFirmware(), async () => { throw new Error('UDP get firmware not supported'); }, 'GET_FIRMWARE');
    }
    async setUser(uid, userid, name, password, role = 0, cardno = 0) {
        return this.functionWrapper(() => this.ztcp.setUser(uid, userid, name, password, role, cardno), async () => { throw new Error('UDP set user not supported'); }, 'SET_USER');
    }
    async deleteUser(uid) {
        return this.functionWrapper(() => this.ztcp.deleteUser(uid), async () => { throw new Error('UDP delete user not supported'); }, 'DELETE_USER');
    }
    async getAttendanceSize() {
        return this.functionWrapper(() => this.ztcp.getAttendanceSize(), async () => { throw new Error('UDP get attendance size not supported'); }, 'GET_ATTENDANCE_SIZE');
    }
    async getAttendances(cb) {
        return this.functionWrapper(() => this.ztcp.getAttendances(cb), () => this.zudp.getAttendances(cb), 'GET_ATTENDANCES');
    }
    async getRealTimeLogs(cb) {
        return this.functionWrapper(() => this.ztcp.getRealTimeLogs(cb), () => this.zudp.getRealTimeLogs(cb), 'GET_REAL_TIME_LOGS');
    }
    async getTemplates() {
        return this.functionWrapper(() => this.ztcp.getTemplates(), async () => { throw new Error('UDP get templates not supported'); }, 'GET_TEMPLATES');
    }
    async saveUserTemplate(user, fingers = []) {
        return await this.functionWrapper(async () => await this.ztcp.saveUserTemplate(user, fingers), async () => { throw new Error('UDP save user template not supported'); }, 'SAVE_USER_TEMPLATE');
    }
    async deleteFinger(uid, fid) {
        if (fid > 9 || 0 > fid)
            throw new Error("fid params out of index");
        if (uid > 3000 || uid < 1)
            throw new Error("fid params out of index");
        return this.functionWrapper(() => this.ztcp.deleteFinger(uid, fid), async () => { throw new Error('UDP delete finger not supported'); }, 'DELETE_FINGER');
    }
    async enrollUser(uid, temp_id, user_id) {
        if (temp_id < 0 || temp_id > 9)
            throw new Error("temp_id out of range 0-9");
        if (uid < 1 || uid > 3000)
            throw new Error("uid out of range 1-3000");
        return this.functionWrapper(() => this.ztcp.enrollUser(uid, temp_id, user_id), async () => { throw new Error('UDP enroll user not supported'); }, 'ENROLL_USER');
    }
    async verifyUser(uid) {
        return this.functionWrapper(() => this.ztcp.verifyUser(uid), async () => { throw new Error('UDP verify user not supported'); }, 'VERIFY_USER');
    }
    async restartDevice() {
        return this.functionWrapper(() => this.ztcp.restartDevice(), async () => { throw new Error('UDP restart device not supported'); }, 'RESTART_DEVICE');
    }
    async getSizes() {
        return this.functionWrapper(() => this.ztcp.getSizes(), () => this.zudp.getInfo(), 'GET_SIZES');
    }
    async disconnect() {
        return this.functionWrapper(() => this.ztcp.disconnect(), () => this.zudp.disconnect(), 'DISCONNECT');
    }
    async freeData() {
        return this.functionWrapper(() => this.ztcp.freeData(), () => this.zudp.freeData(), 'FREE_DATA');
    }
    async disableDevice() {
        return this.functionWrapper(() => this.ztcp.disableDevice(), () => this.zudp.disableDevice(), 'DISABLE_DEVICE');
    }
    async enableDevice() {
        return this.functionWrapper(() => this.ztcp.enableDevice(), () => this.zudp.enableDevice(), 'ENABLE_DEVICE');
    }
    async getInfo() {
        return this.functionWrapper(() => this.ztcp.getInfo(), () => this.zudp.getInfo(), 'GET_INFO');
    }
    async clearAttendanceLog() {
        return this.functionWrapper(() => this.ztcp.clearAttendanceLog(), () => this.zudp.clearAttendanceLog(), 'CLEAR_ATTENDANCE_LOG');
    }
    async clearData() {
        return this.functionWrapper(() => this.ztcp.clearData(), () => this.zudp.clearData(), 'CLEAR_DATA');
    }
    async executeCmd(command, data = '') {
        return this.functionWrapper(() => this.ztcp.executeCmd(command, data), () => this.zudp.executeCmd(command, data), 'EXECUTE_CMD');
    }
}

module.exports = Zklib;
